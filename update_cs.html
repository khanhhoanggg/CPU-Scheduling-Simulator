<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mô phỏng Thuật toán Lập lịch CPU</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); margin-bottom: 30px; text-align: center; }
        .header h1 { color: #667eea; font-size: 32px; margin-bottom: 10px; }
        .header p { color: #666; font-size: 16px; }
        .card { background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); margin-bottom: 30px; }
        .card h2 { color: #333; margin-bottom: 20px; font-size: 24px; text-align: center; }
        .button-group { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; }
        button { padding: 12px 24px; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s; }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5568d3; transform: translateY(-2px); }
        .btn-success { background: #48bb78; color: white; }
        .btn-success:hover { background: #38a169; }
        .btn-secondary { background: #4299e1; color: white; }
        .btn-secondary:hover { background: #3182ce; }
        button:disabled { background: #cbd5e0; cursor: not-allowed; }
        textarea { width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px; resize: vertical; min-height: 220px; }
        textarea:focus { outline: none; border-color: #667eea; }
        .quantum-input { display: flex; justify-content: center; gap: 15px; margin-top: 15px; flex-wrap: wrap; align-items: center; }
        .quantum-input label { font-weight: 600; color: #333; }
        .quantum-input input { width: 80px; padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 8px; text-align: center; }
        .info-box { background: #ebf8ff; border-left: 4px solid #4299e1; padding: 15px; border-radius: 8px; margin-top: 15px; text-align: center; }
        .info-box p { color: #2c5282; font-weight: 600; font-size: 16px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th { background: #f7fafc; padding: 12px; text-align: center; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e2e8f0; }
        td { padding: 12px; text-align: center; border-bottom: 1px solid #e2e8f0; }
        tr:hover { background: #f7fafc; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }
        .stat-card { padding: 20px; border-radius: 10px; text-align: center; }
        .stat-card.blue { background: #ebf8ff; border: 2px solid #4299e1; }
        .stat-card.green { background: #f0fff4; border: 2px solid #48bb78; }
        .stat-card h3 { font-size: 14px; color: #666; margin-bottom: 10px; }
        .stat-card p { font-size: 32px; font-weight: bold; }
        .stat-card.blue p { color: #2c5282; }
        .stat-card.green p { color: #22543d; }
        .hidden { display: none; }
        #fileInput { display: none; }
        .comparison-table th:nth-child(2), .comparison-table td:nth-child(2),
        .comparison-table th:nth-child(3), .comparison-table td:nth-child(3) { text-align: right; }
        .detail-table th:not(:first-child), .detail-table td:not(:first-child) { text-align: center; }
        .waiting-time { color: #4299e1; font-weight: 600; }
        .turnaround-time { color: #48bb78; font-weight: 600; }
        @media (max-width: 768px) {
            .button-group, .quantum-input { flex-direction: column; }
            button, .quantum-input input { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mô phỏng Thuật toán Lập lịch CPU</h1>
            <p>FCFS • SJF • Priority • Round Robin • MLQ • MLFQ</p>
        </div>

        <div class="card">
            <h2>Nhập dữ liệu tiến trình</h2>
            <div class="button-group">
                <button class="btn-primary" onclick="document.getElementById('fileInput').click()">Tải file</button>
                <input type="file" id="fileInput" accept=".txt" onchange="handleFileUpload(event)">
                <button class="btn-success" onclick="loadExample()">Ví dụ mẫu</button>
            </div>

            <textarea id="inputText" placeholder="# Format: PID Arrival Burst Priority
# Priority <=1: Queue 0 (FCFS)
# Priority =2: Queue 1 (RR q=2)
# Priority >=3: Queue 2 (RR q=4)
P1 0 8 2
P2 1 4 1
P3 2 9 3
P4 3 5 2
P5 4 2 1"></textarea>

            <div class="quantum-input">
                <label for="quantum">Quantum (RR):</label>
                <input type="number" id="quantum" value="2" min="1">
                <button class="btn-secondary" onclick="runSimulation()" id="runBtn" disabled>Chạy mô phỏng</button>
            </div>

            <div id="infoBox" class="info-box hidden">
                <p id="infoText"></p>
            </div>
        </div>

        <div id="resultsSection" class="hidden">
            <div class="card">
                <h2>So sánh tổng quan</h2>
                <table class="comparison-table">
                    <thead><tr><th>Thuật toán</th><th>Waiting TB</th><th>Turnaround TB</th></tr></thead>
                    <tbody id="comparisonTableBody"></tbody>
                </table>
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn-primary" onclick="exportResults()">Xuất kết quả (.txt)</button>
                </div>
            </div>
            <div id="detailedResults"></div>
        </div>
    </div>

    <script>
        let processes = [];
        let results = {};

        function parseInput(text) {
            const lines = text.trim().split('\n');
            const procs = [];
            for (let line of lines) {
                line = line.trim();
                if (!line || line.startsWith('#')) continue;
                const parts = line.split(/\s+/);
                if (parts.length >= 3) {
                    procs.push({
                        id: parts[0],
                        arrival: parseInt(parts[1]),
                        burst: parseInt(parts[2]),
                        priority: parts.length > 3 ? parseInt(parts[3]) : 0,
                        remainingBurst: parseInt(parts[2]),
                        start: -1,
                        finish: 0,
                        waiting: 0,
                        turnaround: 0,
                        lastRunTime: parseInt(parts[1]),
                        queueLevel: 0
                    });
                }
            }
            return procs;
        }

        document.getElementById('inputText').addEventListener('input', e => {
            processes = parseInput(e.target.value);
            updateInfoBox();
        });

        function updateInfoBox() {
            const box = document.getElementById('infoBox');
            const txt = document.getElementById('infoText');
            const btn = document.getElementById('runBtn');
            if (processes.length > 0) {
                box.classList.remove('hidden');
                txt.textContent = `Đã tải ${processes.length} tiến trình`;
                btn.disabled = false;
            } else {
                box.classList.add('hidden');
                btn.disabled = true;
            }
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = ev => {
                    document.getElementById('inputText').value = ev.target.result;
                    processes = parseInput(ev.target.result);
                    updateInfoBox();
                };
                reader.readAsText(file);
            }
        }

        function loadExample() {
            const example = `P1 0 8 2
P2 1 4 1
P3 2 9 3
P4 3 5 2
P5 4 2 1`;
            document.getElementById('inputText').value = example;
            processes = parseInput(example);
            updateInfoBox();
        }

        // FCFS
        function fcfs(procs) {
            const p = procs.map(x => ({...x}));
            p.sort((a, b) => a.arrival - b.arrival);
            let t = 0;
            p.forEach(pr => {
                pr.start = Math.max(t, pr.arrival);
                pr.finish = pr.start + pr.burst;
                pr.waiting = pr.start - pr.arrival;
                pr.turnaround = pr.finish - pr.arrival;
                t = pr.finish;
            });
            return p;
        }

        // SJF
        function sjf(procs) {
            const p = procs.map(x => ({...x, remainingBurst: x.burst}));
            const res = [];
            let t = 0;
            while (res.length < p.length) {
                const ready = p.filter(pr => pr.arrival <= t && pr.remainingBurst > 0);
                if (ready.length === 0) { t++; continue; }
                ready.sort((a, b) => a.burst - b.burst);
                const pr = ready[0];
                pr.start = t;
                pr.finish = t + pr.burst;
                pr.waiting = pr.start - pr.arrival;
                pr.turnaround = pr.finish - pr.arrival;
                pr.remainingBurst = 0;
                t = pr.finish;
                res.push(pr);
            }
            return res;
        }

        // Priority
        function priorityScheduling(procs) {
            const p = procs.map(x => ({...x, remainingBurst: x.burst}));
            const res = [];
            let t = 0;
            while (res.length < p.length) {
                const ready = p.filter(pr => pr.arrival <= t && pr.remainingBurst > 0);
                if (ready.length === 0) { t++; continue; }
                ready.sort((a, b) => a.priority - b.priority);
                const pr = ready[0];
                pr.start = t;
                pr.finish = t + pr.burst;
                pr.waiting = pr.start - pr.arrival;
                pr.turnaround = pr.finish - pr.arrival;
                pr.remainingBurst = 0;
                t = pr.finish;
                res.push(pr);
            }
            return res;
        }

        // Round Robin - GIỐNG HỆT C++
        function roundRobin(procs, quantum) {
            const p = procs.map(x => ({...x}));
            const n = p.length;
            const queue = [];
            const inQueue = new Array(n).fill(false);
            let t = 0;
            let idx = 0;
            let completed = 0;

            p.sort((a, b) => a.arrival - b.arrival);
            if (n > 0) t = p[0].arrival;

            while (completed < n) {
                while (idx < n && p[idx].arrival <= t) {
                    if (p[idx].remainingBurst > 0 && !inQueue[idx]) {
                        queue.push(idx);
                        inQueue[idx] = true;
                    }
                    idx++;
                }

                if (queue.length === 0) {
                    if (idx < n) t = p[idx].arrival;
                    else break;
                    continue;
                }

                const i = queue.shift();
                inQueue[i] = false;
                const pr = p[i];

                pr.waiting += t - pr.lastRunTime;
                if (pr.start === -1) pr.start = t;

                const exec = Math.min(quantum, pr.remainingBurst);
                t += exec;
                pr.remainingBurst -= exec;
                pr.lastRunTime = t;

                while (idx < n && p[idx].arrival <= t) {
                    if (p[idx].remainingBurst > 0 && !inQueue[idx]) {
                        queue.push(idx);
                        inQueue[idx] = true;
                    }
                    idx++;
                }

                if (pr.remainingBurst > 0) {
                    queue.push(i);
                    inQueue[i] = true;
                } else {
                    pr.finish = t;
                    pr.turnaround = t - pr.arrival;
                    completed++;
                }
            }
            return p;
        }

        // MLQ - GIỐNG HỆT C++
        function mlq(procs) {
            const queues = [[], [], []];
            procs.forEach(pr => {
                const p = {...pr, remainingBurst: pr.burst, lastRunTime: pr.arrival};
                if (p.priority <= 1) queues[0].push(p);
                else if (p.priority === 2) queues[1].push(p);
                else queues[2].push(p);
            });

            let t = 0;
            const result = [];

            // Q0: FCFS
            queues[0].sort((a, b) => a.arrival - b.arrival);
            queues[0].forEach(p => {
                p.start = Math.max(t, p.arrival);
                p.finish = p.start + p.burst;
                p.waiting = p.start - p.arrival;
                p.turnaround = p.finish - p.arrival;
                p.queueLevel = 0;
                t = p.finish;
                result.push(p);
            });

            // Q1: RR q=2
            if (queues[1].length > 0) {
                queues[1].forEach(p => { p.arrival = Math.max(p.arrival, t); p.lastRunTime = p.arrival; });
                const rr = roundRobin(queues[1], 2);
                rr.forEach(p => { p.queueLevel = 1; result.push(p); t = Math.max(t, p.finish); });
            }

            // Q2: RR q=4
            if (queues[2].length > 0) {
                queues[2].forEach(p => { p.arrival = Math.max(p.arrival, t); p.lastRunTime = p.arrival; });
                const rr = roundRobin(queues[2], 4);
                rr.forEach(p => { p.queueLevel = 2; result.push(p); });
            }

            return result;
        }

        // MLFQ - GIỐNG HỆT C++
        function mlfq(procs) {
            const p = procs.map(x => ({...x, remainingBurst: x.burst, queueLevel: 0, lastRunTime: x.arrival}));
            const queues = [[], [], []];
            const quantums = [2, 4, Infinity];
            let t = p.length > 0 ? Math.min(...p.map(pr => pr.arrival)) : 0;
            let completed = 0;

            while (completed < p.length) {
                p.forEach((pr, i) => {
                    if (pr.arrival <= t && pr.remainingBurst > 0 && pr.queueLevel === 0 && !queues[0].includes(i)) {
                        queues[0].push(i);
                    }
                });

                let selected = -1;
                let level = -1;
                for (let l = 0; l < 3; l++) {
                    if (queues[l].length > 0) {
                        selected = queues[l].shift();
                        level = l;
                        break;
                    }
                }

                if (selected === -1) { t++; continue; }

                const pr = p[selected];
                pr.waiting += t - pr.lastRunTime;
                if (pr.start === -1) pr.start = t;

                const exec = Math.min(quantums[level] === Infinity ? pr.remainingBurst : quantums[level], pr.remainingBurst);
                t += exec;
                pr.remainingBurst -= exec;
                pr.lastRunTime = t;

                if (pr.remainingBurst > 0) {
                    const nextLevel = Math.min(level + 1, 2);
                    pr.queueLevel = nextLevel;
                    queues[nextLevel].push(selected);
                } else {
                    pr.finish = t;
                    pr.turnaround = t - pr.arrival;
                    completed++;
                }
            }
            return p;
        }

        function calculateAvg(procs) {
            const n = procs.length;
            const w = procs.reduce((s, p) => s + p.waiting, 0) / n;
            const ta = procs.reduce((s, p) => s + p.turnaround, 0) / n;
            return { avgWaiting: w, avgTurnaround: ta };
        }

        function runSimulation() {
            if (processes.length === 0) return;
            const q = parseInt(document.getElementById('quantum').value) || 2;

            const fcfsRes = fcfs(processes);
            const sjfRes = sjf(processes);
            const prioRes = priorityScheduling(processes);
            const rrRes = roundRobin(processes.map(p => ({...p, remainingBurst: p.burst, lastRunTime: p.arrival})), q);
            const mlqRes = mlq(processes);
            const mlfqRes = mlfq(processes);

            results = {
                fcfs: { proc: fcfsRes, ...calculateAvg(fcfsRes) },
                sjf: { proc: sjfRes, ...calculateAvg(sjfRes) },
                priority: { proc: prioRes, ...calculateAvg(prioRes) },
                rr: { proc: rrRes, ...calculateAvg(rrRes) },
                mlq: { proc: mlqRes, ...calculateAvg(mlqRes) },
                mlfq: { proc: mlfqRes, ...calculateAvg(mlfqRes) },
                quantum: q
            };

            displayResults();
        }

        function displayResults() {
            document.getElementById('resultsSection').classList.remove('hidden');
            document.getElementById('comparisonTableBody').innerHTML = `
                <tr><td>FCFS</td><td>${results.fcfs.avgWaiting.toFixed(2)}</td><td>${results.fcfs.avgTurnaround.toFixed(2)}</td></tr>
                <tr><td>SJF</td><td>${results.sjf.avgWaiting.toFixed(2)}</td><td>${results.sjf.avgTurnaround.toFixed(2)}</td></tr>
                <tr><td>Priority</td><td>${results.priority.avgWaiting.toFixed(2)}</td><td>${results.priority.avgTurnaround.toFixed(2)}</td></tr>
                <tr><td>Round Robin (q=${results.quantum})</td><td>${results.rr.avgWaiting.toFixed(2)}</td><td>${results.rr.avgTurnaround.toFixed(2)}</td></tr>
                <tr><td>MLQ</td><td>${results.mlq.avgWaiting.toFixed(2)}</td><td>${results.mlq.avgTurnaround.toFixed(2)}</td></tr>
                <tr><td>MLFQ</td><td>${results.mlfq.avgWaiting.toFixed(2)}</td><td>${results.mlfq.avgTurnaround.toFixed(2)}</td></tr>
            `;

            const algos = [
                { name: 'FCFS', key: 'fcfs' },
                { name: 'SJF', key: 'sjf' },
                { name: 'Priority', key: 'priority', showPri: true },
                { name: `Round Robin (q=${results.quantum})`, key: 'rr' },
                { name: 'MLQ', key: 'mlq', showQ: true },
                { name: 'MLFQ', key: 'mlfq', showQ: true }
            ];

            document.getElementById('detailedResults').innerHTML = algos.map(a => `
                <div class="card">
                    <h2>${a.name}</h2>
                    <table class="detail-table">
                        <thead>
                            <tr>
                                <th>PID</th><th>Arrival</th><th>Burst</th>
                                ${a.showPri ? '<th>Priority</th>' : ''}
                                ${a.showQ ? '<th>Queue</th>' : ''}
                                <th>Start</th><th>Finish</th><th>Waiting</th><th>Turnaround</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${results[a.key].proc.map(p => `
                                <tr>
                                    <td><strong>${p.id}</strong></td>
                                    <td>${p.arrival}</td>
                                    <td>${p.burst}</td>
                                    ${a.showPri ? `<td>${p.priority}</td>` : ''}
                                    ${a.showQ ? `<td>${p.queueLevel}</td>` : ''}
                                    <td>${p.start}</td>
                                    <td>${p.finish}</td>
                                    <td class="waiting-time">${p.waiting}</td>
                                    <td class="turnaround-time">${p.turnaround}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    <div class="stats-grid">
                        <div class="stat-card blue"><h3>Waiting TB</h3><p>${results[a.key].avgWaiting.toFixed(2)}</p></div>
                        <div class="stat-card green"><h3>Turnaround TB</h3><p>${results[a.key].avgTurnaround.toFixed(2)}</p></div>
                    </div>
                </div>
            `).join('');

            document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
        }

        function exportResults() {
            let txt = "KET QUA MO PHONG CPU SCHEDULING\n\n";
            const keys = ['fcfs','sjf','priority','rr','mlq','mlfq'];
            keys.forEach(k => {
                const name = k.toUpperCase() + (k === 'rr' ? ` (q=${results.quantum})` : '');
                txt += `--- ${name} ---\n`;
                txt += "PID\tArr\tBurst\tStart\tFinish\tWait\tTurn\n";
                results[k].proc.forEach(p => {
                    txt += `${p.id}\t${p.arrival}\t${p.burst}\t${p.start}\t${p.finish}\t${p.waiting}\t${p.turnaround}\n`;
                });
                txt += `\nAvg Waiting: ${results[k].avgWaiting.toFixed(2)}\n`;
                txt += `Avg Turnaround: ${results[k].avgTurnaround.toFixed(2)}\n\n`;
            });
            const blob = new Blob([txt], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'ket_qua_cpu_scheduling.txt';
            a.click();
        }
    </script>
</body>
</html>